<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序学习(一)]]></title>
    <url>%2F2018%2F05%2F16%2Fwxapp%2F</url>
    <content type="text"><![CDATA[微信小程序初探历史: 移动互联网时代 2010-2016 85后的大佬 滴滴4年 传统 APP：安装大小、流量安装、占手机内存、耗电 2017 - 物联网 人工智能时代 wxapp 微信赋能 微信关系链 不用安装 用完即走 小到 1m 以内 开发成本最低 html5/css3/es6 来开发 现在：一些(10个以内)巨无霸 APP 流量入口 再装一堆小程序 准备 下载并安装 微信web开发者工具 申请一个小程序账号, 点击 https://mp.weixin.qq.com/wxopen/waregister?action=step1 根据指引填写信息和提交相应的资料, 就可以拥有自己的小程序帐号 登录微信公众平台, 在菜单 “设置”-“开发设置” 看到小程序的 AppID 注意:小程序的 AppID 相当于小程序平台的一个身份证, 后续你会在很多地方要用到 AppID 你也可以参考小程序官方简易教程 第一个小程序打开微信web开发者工具, 用微信扫码登录开发者工具新建项目选择小程序项目, 选择代码存放的硬盘路径, 填入刚刚申请到的小程序的 AppID, 给你的项目起一个好听的名字, 最后, 勾选 “创建 QuickStart 项目” ( 注意: 你要选择一个空的目录才会有这个选项 ), 点击确定, 你就得到了你的第一个小程序了 小程序的目录结构开发者工具将会生成基本框架, 初始化并包含了一些简单的代码文件, 其中app.js、app.json、app.wxss 这三个是必不可少的, 小程序会读取这些文件初始化实例 /pages /index /index.js /index.wxml /index.wxss /logs /utils /util.js /app.js /app.json /app.wxss index 文件夹：首页 logs 文件夹：日志(不必须) utils 文件夹：公共的、通用的文件夹, utils.js 存放公用代码, 比如系统默认写入的日期转化函数 app.js: 逻辑文件 app.json: 配置文件, 有多少个 appy 页面都要在这注册, 还可以进行窗口样式配置 app.wxss: 公共的样式表文件 文件实质: wxml =&gt; html js =&gt; 逻辑 wcss =&gt; css 开发者工具调试区介绍 ConsoleConsole的意思是控制台, 做过开发的都知道几乎每个IDE都会有控制台, 可以显示错误信息和打印变量的信息等 SourcesSources显示了当前项目的所有脚本文件, 微信小程序框架会对这些脚本文件进行编译。Source下边还有一个区域, 做过软件开发的都知道, 一般下边是控制台会显示一些log信息、断电调试等等。 Network有网络请求时, 显示与网络相关的信息 Storage显示当前项目的使用 wx.setStorage 或者 wx.setStorageSync 进行本地存储后的数据存储情况 AppData显示当前项目显示的具体数据, 比如事件对象等]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>wxapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo&NexT 博客个性化主题设置]]></title>
    <url>%2F2018%2F05%2F03%2Fhexo_config%2F</url>
    <content type="text"><![CDATA[Hexo&amp;NexT 博客骚操作-个性化主题设置 最简单的 hexo&amp;next 主题个性化设置 前提须知： 站点配置文件: 根目录下的 _config.yml 主题配置文件: 主题文件夹内的 _config.yml 站内搜索功能 推荐使用 Hexo 提供的 Local Search，通过安装 hexo-generator-search 插件，在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接 安装 hexo-generator-search 和 hexo-generator-searchdb 站点根目录下命令行输入 1234$ npm install hexo-generator-search --save``` ```bash$ npm install hexo-generator-searchdb --save 配置站点 编辑 站点配置文件 _config.yml ，新增以下内容: 12345search:path: search.xmlfield: postformat: htmllimit: 10000 启用本地搜索功能 打开主题配置文件 _config.yml ，设为 true 123# Local searchlocal_search:enable: true 代码块自定义样式 打开\themes\next\source\css_custom\custom.styl向里面加入：(颜色可以自己定义)1234567891011121314// Custom styles.code color #ff7600 background #fbf7f8 margin 2px// 大代码块的自定义样式.highlight, pre margin 5px 0 padding 5px border-radius 3px.highlight, code, pre border 1px solid #d6d6d6 设置头像 编辑站点配置文件, 新增字段 avatar头像的链接地址可以是: 网络地址 1avatar: https://你的头像地址 站内地址 图片文件保存在 根目录 /source/iamges 中 1avatar: ./images/icon.jpg 菜单设置 打开主题配置文件 _config.yml，找到 #Menu Settings123456789menu: home: / || home #主页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #分页 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 去掉 # 以显示需要的菜单项若站点运行在子目录中, 将链接前缀的 / 去掉 点击出现桃心效果(或文字) 桃心效果 点我获取 love.js 源码 在路径 /themes/next/source/js/src 下新建 love.js 文件，并将网址中的代码复制进去 然后打开 /themes/next/layout/_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 文字效果 代码替换为： 1234567891011121314151617181920212223242526272829var a_idx = 0;jQuery(document).ready(function ($) &#123;$("body").click(function (e) &#123; var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY, c = "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"; $i.css(&#123; "z-index": 999, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "font-size": "3em", "color": c &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 1500, function () &#123; $i.remove(); &#125;);&#125;);&#125;); 自定义添加 js/themes/next/source/js/src 路径下建立 js 文件/themes/next/layout/_layout.swig 下引入 自定义样式themes/next/source/css/custom/_custom.styl 文章阅读次数 创建LeanCloud账号，进入 LeanCloud官网 并注册 进入访问控制台 单击“创建应用”按钮进行应用的创建，输入新应用名称，选择开发版，单击“创建”按钮完成创建 创建Class进入到刚刚创建的应用中，选择左侧导航栏的“存储”，然后点击“创建Class”，为了与Next形成配置关系，将Class名称填为Counter，并选择 第一项 限制写入 限制写入 限制写入，重要的事情说三次，然后单击“创建Class”按钮完成Class的创建 配置Key在左侧导航栏的设置界面，单击“应用Key”可以看到应用的App ID和App Key 复制ID和Key，然后将其配置到主题配置文件中，在文件中找到leancloud_visitors属性，将enable设置为true，然后将之前复制的ID和Key粘贴到相应的属性中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: HCmcHOKGNq马赛克BTx7MtHpj-gzGzoHsz app_key: Lo4pIArbo马赛克liHjN6UMsk 字数统计NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件(Blog\themes\next_config.yml)中打开wordcount 统计功能即可12345# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:item_text: truewordcount: true 找到Blog\themes\next\layout\_macro\post.swig 文件,将下面代码后面加 “字”123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; tags 标签创建与样式修改创建 tags命令行输入hexo new page &quot;tags&quot; 在myBlog/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件 编辑 tags 文件夹下的 index.md12345---title: tagsdate: 2017-07-10 16:36:26type: &quot;tags&quot;--- 编辑主题的 themes/next/_config.yml ，添加tags 到 menu 中12345menu:home: /archives: /archives/categories: /categories/tags: /tags/ 修改样式路径themes\next\source\css\_common\components\post\post-tags.styl1234567891011.posts-expand .post-tags margin-top 40px text-align center a display inline-block margin-right 10px font-size 13px border 1px solid #ccc border-radius 5px color #0593d3 添加 “文章标签” 字样路径 themes\next\layout\_macro\post.swig123456789&lt;footer class=&quot;post-footer&quot;&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class=&quot;post-tags&quot;&gt; 文章标签: &#123;% for tag in post.tags %&#125; &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>博客</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 语言精粹学习笔记]]></title>
    <url>%2F2018%2F05%2F01%2Fnote%2F</url>
    <content type="text"><![CDATA[函数 (Functions)函数对象JavaScript 中的函数就是对象，函数可以保存在变量、对象和数组中，可以被当做参数传递给其他函数，函数也可以再返回函数，函数可以拥有方法 通过字面量创建函数123var func = function(a) &#123; return a;&#125; 函数调用函数调用会暂停当前函数的执行，传递控制权和参数给新函数 除了声明时定义的形参，每个函数接收两个附加的参数 this 和 arguments 当实参和形参个数不匹配时，不会导致运行错误，实参过多则忽略超出的参数，实参不足则缺失的参数默认为 undefined，而且对参数不会进行类型检查。 JavaScript 中有四种调用模式： 方法调用模式 当函数被保存为对象的一个属性时，称之为方法。 如果调用表达式包含一个提取属性的动作：：.表达式或[]下标表达式，就是被当做方法调用。 12345678var obj = &#123; value: 0, show: function() &#123; console.log(this.value); &#125;&#125; obj.show(); 通过 this 可以取得上下文方法称为公共方法 函数调用模式 当一个函数并非一个对象属性时，就是被当做一个函数来调用的。 12345678910111213141516var myObject = &#123; value: 0&#125; myObject.double = function() &#123; var that = this; var helper = function() &#123; console.log(this.value) // undefined console.log(that.value) // 0 &#125; helper(); // 以函数的形式调用&#125; myObject.double() // 以方法的形式调用 以此模式调用函数时，this 将会绑定到全局对象，而内部函数的 this 无法绑定外部函数 的this 变量，所以不能共享访问权。 解决办法：外部定义一个 that 变量保存 this 的值，内部函数通过 that 访问。 构造器调用模式 如果一个类需要通过 new 关键字调用，那就是构造函数。 1234var Func = function(string) &#123; this.status = string;&#125;var myFunc = new Func('construct'); apply 调用模式 apply 方法需要构建一个参数数组传递给调用函数 12var arr = [1, 2];var sum = add.apply(arr, [3, 4]); 返回 Return一个函数总会返回一个值，如果没有指定返回值，则返回 undefined。 return; 可用来使函数提前返回 异常 Exceptions123456789101112131415var add = function(a) &#123; if (a != 'number') &#123; throw &#123; name: 'TypeError', message: 'a need to be number' &#125; &#125;&#125; try &#123; add('a')&#125; catch (error) &#123; console.log(error) // &#123;name: 'TypeError',message: 'a need to be number'&#125; // console.log(error.name + error.message)&#125; 扩充类型的功能 通过给 Object.prototype 添加方法，可以让该方法对所有对象都可用。 1234567891011Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125; // 去除首位空格String.method('trim', function() &#123; return this.replace(/^\s+|\s+$/g, '');&#125;) console.log(" neat ".trim()); // neat 递归 函数自己调用自己，称为函数的递归调用 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log("a");&#125;fun(); 作用域 Scope作用域控制着变量与参数的可以性及声明周期。 减少了名称冲突，并且提供了自动内存管理。 函数内部可以直接读取全局变量，函数外部无法读取函数内部的局部变量 但实际上 JavaScript 语法并不支持块级作用域，函数中的参数和变量在外部不可见，在内部可见 12345678910var foo = function() &#123; var a = 3, b = 5; var bar = function() &#123; var a = 4, b = 6; console.log('a ' + a + ', b ' + b); // a = 4, b = 6 &#125;() console.log('a ' + a + ', b ' + b); // a = 3, b = 5&#125;() 闭包 Closure闭包就是能够读取其他函数内部变量的函数 由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用： 可以读取函数内部的变量 让这些变量的值始终保持在内存中 123456789101112131415161718192021function f1() &#123; var n = 999; nAdd = function () &#123; n += 1 &#125; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000 匿名函数本身就是闭包 回调 Callback回调函数原理：“我现在出发，到了通知你”。这是一个异步的流程，“我出发”这个过程中（函数执行），“你” 可以去做任何事，“到了”（函数执行完毕）“通知你”（回调）进行之后的流程。 123456789function doSomething(callback) &#123; callback(1,2);&#125;function numberAdd(a,b) &#123; document.write(a+b);&#125;doSomething(numberAdd);//3 模块 Module 模块是一个提供接口却隐藏状态与实现的函数或对象。]]></content>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
