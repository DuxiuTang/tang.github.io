<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo&NexT 博客个性化主题设置]]></title>
    <url>%2F2018%2F05%2F03%2Fhexo_config%2F</url>
    <content type="text"><![CDATA[Hexo&amp;NexT 博客骚操作-个性化主题设置 最简单的 hexo&amp;next 主题个性化设置 前提须知： 站点配置文件: 根目录下的 _config.yml 主题配置文件: 主题文件夹内的 _config.yml 站内搜索功能 推荐使用 Hexo 提供的 Local Search，通过安装 hexo-generator-search 插件，在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接 安装 hexo-generator-search 和 hexo-generator-searchdb 站点根目录下命令行输入 1234$ npm install hexo-generator-search --save``` ```bash$ npm install hexo-generator-searchdb --save 配置站点 编辑 站点配置文件 _config.yml ，新增以下内容: 12345search:path: search.xmlfield: postformat: htmllimit: 10000 启用本地搜索功能 打开主题配置文件 _config.yml ，设为 true 123# Local searchlocal_search:enable: true 代码块自定义样式 打开\themes\next\source\css_custom\custom.styl向里面加入：(颜色可以自己定义)1234567891011121314// Custom styles.code color #ff7600 background #fbf7f8 margin 2px// 大代码块的自定义样式.highlight, pre margin 5px 0 padding 5px border-radius 3px.highlight, code, pre border 1px solid #d6d6d6 设置头像 编辑站点配置文件, 新增字段 avatar头像的链接地址可以是: 网络地址 1avatar: https://你的头像地址 站内地址 图片文件保存在 根目录 /source/iamges 中 1avatar: ./images/icon.jpg 菜单设置 打开主题配置文件 _config.yml，找到 #Menu Settings123456789menu: home: / || home #主页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #分页 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 去掉 # 以显示需要的菜单项若站点运行在子目录中, 将链接前缀的 / 去掉 点击出现桃心效果(或文字) 桃心效果 点我获取 love.js 源码 在路径 /themes/next/source/js/src 下新建 love.js 文件，并将网址中的代码复制进去 然后打开 /themes/next/layout/_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 文字效果 代码替换为： 1234567891011121314151617181920212223242526272829var a_idx = 0;jQuery(document).ready(function ($) &#123;$("body").click(function (e) &#123; var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY, c = "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"; $i.css(&#123; "z-index": 999, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "font-size": "3em", "color": c &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 1500, function () &#123; $i.remove(); &#125;);&#125;);&#125;); 自定义添加 js/themes/next/source/js/src 路径下建立 js 文件/themes/next/layout/_layout.swig 下引入 自定义样式themes/next/source/css/custom/_custom.styl 文章阅读次数 创建LeanCloud账号，进入 LeanCloud官网 并注册 进入访问控制台 单击“创建应用”按钮进行应用的创建，输入新应用名称，选择开发版，单击“创建”按钮完成创建 创建Class进入到刚刚创建的应用中，选择左侧导航栏的“存储”，然后点击“创建Class”，为了与Next形成配置关系，将Class名称填为Counter，并选择 第一项 限制写入 限制写入 限制写入，重要的事情说三次，然后单击“创建Class”按钮完成Class的创建 配置Key在左侧导航栏的设置界面，单击“应用Key”可以看到应用的App ID和App Key 复制ID和Key，然后将其配置到主题配置文件中，在文件中找到leancloud_visitors属性，将enable设置为true，然后将之前复制的ID和Key粘贴到相应的属性中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: HCmcHOKGNq马赛克BTx7MtHpj-gzGzoHsz app_key: Lo4pIArbo马赛克liHjN6UMsk 字数统计NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件(Blog\themes\next_config.yml)中打开wordcount 统计功能即可12345# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:item_text: truewordcount: true 找到Blog\themes\next\layout\_macro\post.swig 文件,将下面代码后面加 “字”123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>博客</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 语言精粹学习笔记]]></title>
    <url>%2F2018%2F05%2F01%2Fnote%2F</url>
    <content type="text"><![CDATA[函数 (Functions)函数对象JavaScript 中的函数就是对象，函数可以保存在变量、对象和数组中，可以被当做参数传递给其他函数，函数也可以再返回函数，函数可以拥有方法 通过字面量创建函数123var func = function(a) &#123; return a;&#125; 函数调用函数调用会暂停当前函数的执行，传递控制权和参数给新函数 除了声明时定义的形参，每个函数接收两个附加的参数 this 和 arguments 当实参和形参个数不匹配时，不会导致运行错误，实参过多则忽略超出的参数，实参不足则缺失的参数默认为 undefined，而且对参数不会进行类型检查。 JavaScript 中有四种调用模式： 方法调用模式 当函数被保存为对象的一个属性时，称之为方法。 如果调用表达式包含一个提取属性的动作：：.表达式或[]下标表达式，就是被当做方法调用。 12345678var obj = &#123; value: 0, show: function() &#123; console.log(this.value); &#125;&#125; obj.show(); 通过 this 可以取得上下文方法称为公共方法 函数调用模式 当一个函数并非一个对象属性时，就是被当做一个函数来调用的。 12345678910111213141516var myObject = &#123; value: 0&#125; myObject.double = function() &#123; var that = this; var helper = function() &#123; console.log(this.value) // undefined console.log(that.value) // 0 &#125; helper(); // 以函数的形式调用&#125; myObject.double() // 以方法的形式调用 以此模式调用函数时，this 将会绑定到全局对象，而内部函数的 this 无法绑定外部函数 的this 变量，所以不能共享访问权。 解决办法：外部定义一个 that 变量保存 this 的值，内部函数通过 that 访问。 构造器调用模式 如果一个类需要通过 new 关键字调用，那就是构造函数。 1234var Func = function(string) &#123; this.status = string;&#125;var myFunc = new Func('construct'); apply 调用模式 apply 方法需要构建一个参数数组传递给调用函数 12var arr = [1, 2];var sum = add.apply(arr, [3, 4]); 返回 Return一个函数总会返回一个值，如果没有指定返回值，则返回 undefined。 return; 可用来使函数提前返回 异常 Exceptions123456789101112131415var add = function(a) &#123; if (a != 'number') &#123; throw &#123; name: 'TypeError', message: 'a need to be number' &#125; &#125;&#125; try &#123; add('a')&#125; catch (error) &#123; console.log(error) // &#123;name: 'TypeError',message: 'a need to be number'&#125; // console.log(error.name + error.message)&#125; 扩充类型的功能 通过给 Object.prototype 添加方法，可以让该方法对所有对象都可用。 1234567891011Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125; // 去除首位空格String.method('trim', function() &#123; return this.replace(/^\s+|\s+$/g, '');&#125;) console.log(" neat ".trim()); // neat 递归 函数自己调用自己，称为函数的递归调用 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log("a");&#125;fun(); 作用域 Scope作用域控制着变量与参数的可以性及声明周期。 减少了名称冲突，并且提供了自动内存管理。 函数内部可以直接读取全局变量，函数外部无法读取函数内部的局部变量 但实际上 JavaScript 语法并不支持块级作用域，函数中的参数和变量在外部不可见，在内部可见 12345678910var foo = function() &#123; var a = 3, b = 5; var bar = function() &#123; var a = 4, b = 6; console.log('a ' + a + ', b ' + b); // a = 4, b = 6 &#125;() console.log('a ' + a + ', b ' + b); // a = 3, b = 5&#125;() 闭包 Closure闭包就是能够读取其他函数内部变量的函数 由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用： 可以读取函数内部的变量 让这些变量的值始终保持在内存中 123456789101112131415161718192021function f1() &#123; var n = 999; nAdd = function () &#123; n += 1 &#125; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000 匿名函数本身就是闭包 回调 Callback回调函数原理：“我现在出发，到了通知你”。这是一个异步的流程，“我出发”这个过程中（函数执行），“你” 可以去做任何事，“到了”（函数执行完毕）“通知你”（回调）进行之后的流程。 123456789function doSomething(callback) &#123; callback(1,2);&#125;function numberAdd(a,b) &#123; document.write(a+b);&#125;doSomething(numberAdd);//3 模块 Module 模块是一个提供接口却隐藏状态与实现的函数或对象。]]></content>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
