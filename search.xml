<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mpvue 初识]]></title>
    <url>%2F2018%2F06%2F04%2Fmpvue%2F</url>
    <content type="text"><![CDATA[mpvue初识之安装和使用安装和初始化安装 vue-cli1yarn global vue-cli | npm install -g vue-cli 初始化一个项目1vue init mpvue/mpvue-quickstart projName 输出1234567891011121314151617181920$ vue init mpvue/mpvue-quickstart projName? Project name projName? wxmp appid wxfc097****b431e? Project description A Mpvue project? Author tanglin &lt;2196****5@qq.com&gt;? Vue build runtime? Use Vuex? No? Use ESLint to lint your code? No? 小程序测试，敬请关注最新微信开发者工具的“测试报告”功能 vue-cli · Generated "mpvue-demo". To get started: cd mpvue-demo npm install npm run dev Documentation can be found at http://mpvue.com package.jsonscripts 可运行脚本, 可以发出的命令dependencies (上线、整个项目)依赖devDependencies (运行、开发时)依赖babelpx2rpxwebpack npm run 输出当前可运行脚本npm run dev运行 dev 脚本“dev”: “node build/dev-server.js” 打开开发者main.js 是入口文件 几个简单的 mpvue 操作 v-modules 数据绑定 1&lt;input type="text" v-model="myTodo" placeholder="点我" /&gt; @click 事件绑定 1&lt;button @click="addTodo"&gt;按钮&lt;/button&gt; v-for 循环 1&lt;li v-key="i" v-for="(todo, i) in todos" :class="&#123;'done': todo.done&#125;" @click="toggle(i)"&gt;&#123;&#123;todo.text&#125;&#125; ？ &#123;&#123;todo.done&#125;&#125;&lt;/li&gt; v-for 中是一个类似 for..in 的循环结构，指定( key, index ): 动态绑定属性，标签或组件的属性是跟data相关:class=&quot;{&#39;done&#39;: todo.done}&quot; 表示后面为 true 则赋给前面的类名@click() 函数可以传参一个 {} 表示js 运行区域 computed: {} 计算属性Vue里面，就像所有的方法都在methods中一样，所有的计算属性都写在 vue 实例的 computed 属性中，这个计算属性就是一个函数，返回值为最后属性的值。定义完成之后，我们就可以像用普通属性一样去用计算属性。计算属性的方法可以包含很多繁重的逻辑，最终返回我们需要的值]]></content>
      <tags>
        <tag>vue</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序组件化开发框架 WePY 初体验]]></title>
    <url>%2F2018%2F06%2F04%2Fwepy%2F</url>
    <content type="text"><![CDATA[微信小程序组件化开发框架 WePY 初体验 写在前面：组件化开发的组价(Component)，说的不是小程序中的 scroll-view 这种页面组件，而是指一些设计为通用性的，用来构建较大型应用程序的软件，如 UI 组件。核心意义在于复用。WePY 就是基于 Vue、react 在 MVVM 基础上建立起来的组件开发框架。 WePY项目的创建全局安装或更新WePY命令行工具1npm install wepy-cli -g 初始化一个项目1wepy init standard myproject 输出，后面几个选择 no 暂时用不上123456789? Project name 项目名称? AppId wxfc0******1e 你的AppId? Project description A WePY 项目名称? Author ta***in 2196****35@qq.com ? Use ESLint to lint your code? (y/n) No? Use Redux in your project? (y/n) No? Use web transform feature in your project? (/n) No wepy-cli · Generated "try-wepy". 安装依赖首先要切换至项目目录cd myproject1yarn 或者1npm install 推荐 yarn 根据 package.json 安装依赖文件，将会在 node_modules 文件中添加依赖包 开启实时编译1wepy build --watch 这会像 stylus 一样开始编译并监听文件改变，此时会生成 dist 目录（小程序目录，微信开发者工具从此处打开小程序），我们的开发目录在 src/ 下 WePY项目的目录结构1234567891011├── dist 小程序运行代码目录（该目录由WePY的build指令自动编译生成，请不要直接修改该目录下的文件）├── node_modules ├── src 代码编写的目录（该目录为使用WePY后的开发目录）| ├── components WePY组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy 可复用的WePY组件a| | └── com_b.wpy 可复用的WePY组件b| ├── pages WePY页面目录（属于完整页面）| | ├── index.wpy index页面（经build后，会在dist目录下的pages目录生成index.js、index.json、index.wxml和index.wxss文件）| | └── other.wpy other页面（经build后，会在dist目录下的pages目录生成other.js、other.json、other.wxml和other.wxss文件）| └── app.wpy 小程序配置项（全局数据、样式、声明钩子等；经build后，会在dist目录下生成app.js、app.json和app.wxss文件）└── package.json 项目的package配置 添加项目 app.wpy app.wpy 文件其实就是小程序中的 app.json 文件，我们在这个文件中注册 App 的页面，参照这一段 123456789export default class extends wepy.app &#123; config = &#123; pages: [ &apos;pages/home&apos;, &apos;pages/classify&apos;, &apos;pages/shop_cart&apos;, &apos;pages/info&apos;, &apos;pages/index&apos; ], 新建文件在 src/pages/ 目录下新建注册的页面，后缀名为 .wpy 基本格式 12345678910111213141516&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;&lt;template&gt; &lt;view&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; // wepy 在本地的 node_modules/ 下（其实也在全局，如果全局安装了 wepy） import wepy from &apos;wepy&apos; // 单页面组件 export default class Home extends wepy.page &#123; // es6 class 内部，不是 json 不使用 : data = &#123; &#125; &#125;&lt;/script&gt; 微信开发者工具使用微信开发者工具–&gt;添加项目，项目目录请选择 dist 目录，即可根据配置（project.config.json）完成项目信息自动配置。 打开你就能看到你的小程序了 其他 依赖管理何为依赖管理？ 依赖管理说白了就是构建一个有向无环图。项目A依赖项目B，项目B依赖项目C，那么当你的项目依赖A的时候，依赖管理工具会自动让你的项目依赖B和C。 要想构建有向无环图，最关键的是要将项目转化为有向无环图中的结点。所以对于项目往往有description，作者信息，版本信息等额外信息。 全局样式app.wpy 文件中 &lt;style&gt;&lt;/style&gt; 存放全局样式，我们通常在这里引入公共样式、基础样式等 组件 component 化开发 在 component 文件夹内定义组件export default class Card extends wepy.component意思是说：基于wepy.component 类新生出一个组件类，将此组件以模块的方式向外输出 页面引入组件，至此，页面开发不叫页面开发，而是组件开发，页面由组件构成，将页面分为几个组件就如飞机，全世界都在生产，组装在美国 在页面的 script component 区域内 声明一下123component = &#123; 组件名card: 类名Card,&#125; 组件式开发将类以 html 标签的形式在页面上显示 除了小程序 的页面组件之外，我们可以定制，可以使用社区的组件，可以从 github…]]></content>
      <tags>
        <tag>wepy</tag>
        <tag>小程序</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序解析html标签wxPrase插件]]></title>
    <url>%2F2018%2F05%2F21%2FwxPrase%2F</url>
    <content type="text"><![CDATA[小程序解析html标签wxPrase插件前言通常我们在开发小程序（从列表页跳转到详情页）通过富文本编辑器返回的数据一般都是html的标签，但是偏偏微信小程序本身是不支持HTML标签的，所以我们在解析内容的时候就需要将内容中的HTML标签转换成微信小程序所支持的标签。那么有没有这样一个东西能够将 html 解析为 小程序能够识别的标签呢，wxPrase插件就是这样一款插件 使用方法 导入下载好的wxPrase文件在项目中（直接复制便是）； 在相应的详情XXX.wxml 文件中引入wxParse.wxml (引入文件最好放在第一行)； 例如：&lt;import src=&quot;../../wxParse/wxParse.wxml&quot;/&gt; 在相应的详情XXX.wxss文件中引入wxParse.wxss (引入文件最好放在第一行)； 例如：@import &quot;../../wxParse/wxParse.wxss&quot;; 在相应的详情XXX.js里的onLoad()方法里面写上：WxParse.wxParse(&#39;content&#39;, &#39;html&#39;, content, that, 0) content：第一个参数表示绑定的数据（必填）； html：第二个参数被转换的是html（必填）; content:请求回来的数据（必填）； that:一般为this，指的就是js里的page对象，如果没有var that=this,这是一个必填项就是this（必填）; 0:最后一个参数为imagePadding为当图片自适应是左右的单一padding(默认为0,可选) ##1234// WxParse HtmlFormater 用来解析 content 文本为小程序视图import WxParse from ../../lib/wxParse/wxParse;// 把 html 转为化标准安全的格式import HtmlFormater from ../../lib/htmlFormater;]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6 解构]]></title>
    <url>%2F2018%2F05%2F21%2Fes6-destructuring%2F</url>
    <content type="text"><![CDATA[对象解构 对象字面量的语法形式是在一个赋值操作符左边放置一个对象字面量 1234567let node = &#123; type: "Identifier", name: "foo"&#125;let &#123; type, name &#125; = nodeconsole.log(type) // "Identifier"console.log(name) // "foo" 如果已经存在type、name，重新赋值 使用解构的话则需要在表达式两侧加小括号 12345678let node = &#123; type: 'Identifier', name: 'angela'&#125;, type = 'demo', name = 1;//添加小括号可以将块语句转化为一个表达式，从而实现整个解构赋值的过程(&#123; type, name &#125; = node) 如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined，也可以自己设置一个默认值 12345678let node = &#123; type: "Identifier", name: "foo"&#125;;let &#123; type, name, value = true &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // true 嵌套对象解构 1234567891011121314151617let node = &#123; type: "Identifier", name: "foo", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125;&#125;&#125;;let &#123; loc: &#123; start &#125;&#125; = node;console.log(start.line); // 1console.log(start.column); // 1 数组解构先来看几个简单明了的例子123let colors = ['red', 'green', 'blue']let [, , thirdColor] = colorsconsole.log(thirdColor) // blue 12345let colors = ['red', 'green', 'blue'], firstColor = 'black', secondColor = 'purple';[firstColor, secondColor] = colorsconsole.log(firstColor, secondColor) // red green 变量交换123456789// 传统做法let a = 1, b = 2, tmp;tmp = a;a = b;b = tmp;console.log(a); // 2console.log(b); // 1 12345// 使用解构赋值let a = 1, b = 2;[a, b] = [b, a]console.log(a, b) // 2 1 数组解构中有一个不定元素的概念，可以通过…语法将数组中的其余元素赋值给一个特定的变量 12let colors = ['red', 'green', 'blue'];let [firstColor, ...restColors] = colors//restColors包含两个元素green和blue 最好的办法是既使用默认值，又使用解构 12345678const DEFAULT_REQUEST_OPTIONS = &#123; url: '', data: &#123;&#125;, header: &#123;'Content-Type': 'application/json'&#125;, method: 'GET', dataType: 'json'&#125;let &#123;url, data, header, method, dataType, mock=false&#125; = options]]></content>
  </entry>
  <entry>
    <title><![CDATA[Object.assign()]]></title>
    <url>%2F2018%2F05%2F20%2Fes6-assign()%2F</url>
    <content type="text"><![CDATA[语法1Object.assign(target, ...sources) Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 拷贝一份 assign 用于(指向)生成新对象.可以用来合并对象12345678910111213141516var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。``` ```js// 合并具有相同属性的对象var o1 = &#123; a: 1, b: 1, c: 1 &#125;;var o2 = &#123; b: 2, c: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 针对深拷贝，需要使用其他方法 因为 Object.assign()拷贝的是属性值 , 继承属性和不可枚举属性是不能拷贝的123456//深拷贝const c = &#123;t: 1, p: 'gg'&#125;;const d = deepCopy(c);d.t = 3;console.log(c); // &#123;t: 1, p: 'gg'&#125;console.log(d); // &#123;t: 3, p: 'gg'&#125; 用例12345678910111213141516const defaultOpt = &#123; title: 'hello', name: 'oo', type: 'line'&#125;;// 原来可能需要这样const opt1 = deepCopy(a);opt1.title = 'opt1';opt1.type = 'bar';opt1.extra = 'extra'; // 额外增加配置// 现在只要这样const opt2 = Object.assign(&#123;&#125;, a, &#123; title: 'opt2', type: 'bar', extra: 'extra'&#125;);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F16%2Fques-1px%2F</url>
    <content type="text"><![CDATA[移动 Web 1像素 问题问题：一般在移动端，由于dpr（设备像素比）不为1，在PC端显示1像素的边框，在移动端其实显示为2px。解决这个问题，主要思想是：使用伪元素设置1px的边框，然后使用 transform:scale，对边框进行缩放（scaleY）。123456789101112131415// 上边框:before content "" position absolute top 0 left 0 right 0 height 1px border-top 1px solid e5e5e5 color #e5e5e5 -webkit-transform-origin 0 0 transform-origin 0 0 -webkit-transform scaleY(0.5) transform scaleY(0.5) z-index 2 123456789101112131415// 下边框 注意 transform-origin&amp;:after content "" position absolute bottom 0 left 0 right 0 height 1px border-bottom 10px solid #e5e5e5 color #e5e5e5 -webkit-transform-origin 0 100% transform-origin 0 100% -webkit-transform scaleY(0.5) transform scaleY(0.5) z-index 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习(一)]]></title>
    <url>%2F2018%2F05%2F16%2Fwxapp%2F</url>
    <content type="text"><![CDATA[微信小程序初探历史: 移动互联网时代 2010-2016 85后的大佬 滴滴4年 传统 APP：安装大小、流量安装、占手机内存、耗电 2017 - 物联网 人工智能时代 wxapp 微信赋能 微信关系链 不用安装 用完即走 小到 1m 以内 开发成本最低 html5/css3/es6 来开发 现在：一些(10个以内)巨无霸 APP 流量入口 再装一堆小程序 准备 下载并安装 微信web开发者工具 申请一个小程序账号, 点击 https://mp.weixin.qq.com/wxopen/waregister?action=step1 根据指引填写信息和提交相应的资料, 就可以拥有自己的小程序帐号 登录微信公众平台, 在菜单 “设置”-“开发设置” 看到小程序的 AppID 注意:小程序的 AppID 相当于小程序平台的一个身份证, 后续你会在很多地方要用到 AppID 你也可以参考小程序官方简易教程 第一个小程序打开微信web开发者工具, 用微信扫码登录开发者工具新建项目选择小程序项目, 选择代码存放的硬盘路径, 填入刚刚申请到的小程序的 AppID, 给你的项目起一个好听的名字, 最后, 勾选 “创建 QuickStart 项目” ( 注意: 你要选择一个空的目录才会有这个选项 ), 点击确定, 你就得到了你的第一个小程序了 小程序的目录结构开发者工具将会生成基本框架, 初始化并包含了一些简单的代码文件, 其中app.js、app.json、app.wxss 这三个是必不可少的, 小程序会读取这些文件初始化实例 /pages /index /index.js /index.wxml /index.wxss /logs /utils /util.js /app.js /app.json /app.wxss index 文件夹：首页 logs 文件夹：日志(不必须) utils 文件夹：公共的、通用的文件夹, utils.js 存放公用代码, 比如系统默认写入的日期转化函数 app.js: 逻辑文件 app.json: 配置文件, 有多少个 appy 页面都要在这注册, 还可以进行窗口样式配置 app.wxss: 公共的样式表文件 文件实质: wxml =&gt; html js =&gt; 逻辑 wcss =&gt; css 开发者工具调试区介绍 ConsoleConsole的意思是控制台, 做过开发的都知道几乎每个IDE都会有控制台, 可以显示错误信息和打印变量的信息等 SourcesSources显示了当前项目的所有脚本文件, 微信小程序框架会对这些脚本文件进行编译。Source下边还有一个区域, 做过软件开发的都知道, 一般下边是控制台会显示一些log信息、断电调试等等。 Network有网络请求时, 显示与网络相关的信息 Storage显示当前项目的使用 wx.setStorage 或者 wx.setStorageSync 进行本地存储后的数据存储情况 AppData显示当前项目显示的具体数据, 比如事件对象等]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>wxapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo&NexT 博客个性化主题设置]]></title>
    <url>%2F2018%2F05%2F03%2Fhexo_config%2F</url>
    <content type="text"><![CDATA[Hexo&amp;NexT 博客骚操作-个性化主题设置 最简单的 hexo&amp;next 主题个性化设置 前提须知： 站点配置文件: 根目录下的 _config.yml 主题配置文件: 主题文件夹内的 _config.yml 站内搜索功能 推荐使用 Hexo 提供的 Local Search，通过安装 hexo-generator-search 插件，在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接 安装 hexo-generator-search 和 hexo-generator-searchdb 站点根目录下命令行输入 1234$ npm install hexo-generator-search --save``` ```bash$ npm install hexo-generator-searchdb --save 配置站点 编辑 站点配置文件 _config.yml ，新增以下内容: 12345search:path: search.xmlfield: postformat: htmllimit: 10000 启用本地搜索功能 打开主题配置文件 _config.yml ，设为 true 123# Local searchlocal_search:enable: true 代码块自定义样式 打开\themes\next\source\css_custom\custom.styl向里面加入：(颜色可以自己定义)1234567891011121314// Custom styles.code color #ff7600 background #fbf7f8 margin 2px// 大代码块的自定义样式.highlight, pre margin 5px 0 padding 5px border-radius 3px.highlight, code, pre border 1px solid #d6d6d6 设置头像 编辑站点配置文件, 新增字段 avatar头像的链接地址可以是: 网络地址 1avatar: https://你的头像地址 站内地址 图片文件保存在 根目录 /source/iamges 中 1avatar: ./images/icon.jpg 菜单设置 打开主题配置文件 _config.yml，找到 #Menu Settings123456789menu: home: / || home #主页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #分页 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 去掉 # 以显示需要的菜单项若站点运行在子目录中, 将链接前缀的 / 去掉 点击出现桃心效果(或文字) 桃心效果 点我获取 love.js 源码 在路径 /themes/next/source/js/src 下新建 love.js 文件，并将网址中的代码复制进去 然后打开 /themes/next/layout/_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 文字效果 代码替换为： 1234567891011121314151617181920212223242526272829var a_idx = 0;jQuery(document).ready(function ($) &#123;$("body").click(function (e) &#123; var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY, c = "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"; $i.css(&#123; "z-index": 999, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "font-size": "3em", "color": c &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 1500, function () &#123; $i.remove(); &#125;);&#125;);&#125;); 自定义添加 js/themes/next/source/js/src 路径下建立 js 文件/themes/next/layout/_layout.swig 下引入 自定义样式themes/next/source/css/custom/_custom.styl 文章阅读次数 创建LeanCloud账号，进入 LeanCloud官网 并注册 进入访问控制台 单击“创建应用”按钮进行应用的创建，输入新应用名称，选择开发版，单击“创建”按钮完成创建 创建Class进入到刚刚创建的应用中，选择左侧导航栏的“存储”，然后点击“创建Class”，为了与Next形成配置关系，将Class名称填为Counter，并选择 第一项 限制写入 限制写入 限制写入，重要的事情说三次，然后单击“创建Class”按钮完成Class的创建 配置Key在左侧导航栏的设置界面，单击“应用Key”可以看到应用的App ID和App Key 复制ID和Key，然后将其配置到主题配置文件中，在文件中找到leancloud_visitors属性，将enable设置为true，然后将之前复制的ID和Key粘贴到相应的属性中123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: HCmcHOKGNq马赛克BTx7MtHpj-gzGzoHsz app_key: Lo4pIArbo马赛克liHjN6UMsk 字数统计NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件(Blog\themes\next_config.yml)中打开wordcount 统计功能即可12345# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:item_text: truewordcount: true 找到Blog\themes\next\layout\_macro\post.swig 文件,将下面代码后面加 “字”123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; tags 标签创建与样式修改创建 tags命令行输入hexo new page &quot;tags&quot; 在myBlog/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件 编辑 tags 文件夹下的 index.md12345---title: tagsdate: 2017-07-10 16:36:26type: &quot;tags&quot;--- 编辑主题的 themes/next/_config.yml ，添加tags 到 menu 中12345menu:home: /archives: /archives/categories: /categories/tags: /tags/ 修改样式路径themes\next\source\css\_common\components\post\post-tags.styl1234567891011.posts-expand .post-tags margin-top 40px text-align center a display inline-block margin-right 10px font-size 13px border 1px solid #ccc border-radius 5px color #0593d3 添加 “文章标签” 字样路径 themes\next\layout\_macro\post.swig123456789&lt;footer class=&quot;post-footer&quot;&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class=&quot;post-tags&quot;&gt; 文章标签: &#123;% for tag in post.tags %&#125; &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>博客</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 语言精粹学习笔记]]></title>
    <url>%2F2018%2F05%2F01%2Fnote%2F</url>
    <content type="text"><![CDATA[函数 (Functions)函数对象JavaScript 中的函数就是对象，函数可以保存在变量、对象和数组中，可以被当做参数传递给其他函数，函数也可以再返回函数，函数可以拥有方法 通过字面量创建函数123var func = function(a) &#123; return a;&#125; 函数调用函数调用会暂停当前函数的执行，传递控制权和参数给新函数 除了声明时定义的形参，每个函数接收两个附加的参数 this 和 arguments 当实参和形参个数不匹配时，不会导致运行错误，实参过多则忽略超出的参数，实参不足则缺失的参数默认为 undefined，而且对参数不会进行类型检查。 JavaScript 中有四种调用模式： 方法调用模式 当函数被保存为对象的一个属性时，称之为方法。 如果调用表达式包含一个提取属性的动作：：.表达式或[]下标表达式，就是被当做方法调用。 12345678var obj = &#123; value: 0, show: function() &#123; console.log(this.value); &#125;&#125; obj.show(); 通过 this 可以取得上下文方法称为公共方法 函数调用模式 当一个函数并非一个对象属性时，就是被当做一个函数来调用的。 12345678910111213141516var myObject = &#123; value: 0&#125; myObject.double = function() &#123; var that = this; var helper = function() &#123; console.log(this.value) // undefined console.log(that.value) // 0 &#125; helper(); // 以函数的形式调用&#125; myObject.double() // 以方法的形式调用 以此模式调用函数时，this 将会绑定到全局对象，而内部函数的 this 无法绑定外部函数 的this 变量，所以不能共享访问权。 解决办法：外部定义一个 that 变量保存 this 的值，内部函数通过 that 访问。 构造器调用模式 如果一个类需要通过 new 关键字调用，那就是构造函数。 1234var Func = function(string) &#123; this.status = string;&#125;var myFunc = new Func('construct'); apply 调用模式 apply 方法需要构建一个参数数组传递给调用函数 12var arr = [1, 2];var sum = add.apply(arr, [3, 4]); 返回 Return一个函数总会返回一个值，如果没有指定返回值，则返回 undefined。 return; 可用来使函数提前返回 异常 Exceptions123456789101112131415var add = function(a) &#123; if (a != 'number') &#123; throw &#123; name: 'TypeError', message: 'a need to be number' &#125; &#125;&#125; try &#123; add('a')&#125; catch (error) &#123; console.log(error) // &#123;name: 'TypeError',message: 'a need to be number'&#125; // console.log(error.name + error.message)&#125; 扩充类型的功能 通过给 Object.prototype 添加方法，可以让该方法对所有对象都可用。 1234567891011Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125; // 去除首位空格String.method('trim', function() &#123; return this.replace(/^\s+|\s+$/g, '');&#125;) console.log(" neat ".trim()); // neat 递归 函数自己调用自己，称为函数的递归调用 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log("a");&#125;fun(); 作用域 Scope作用域控制着变量与参数的可以性及声明周期。 减少了名称冲突，并且提供了自动内存管理。 函数内部可以直接读取全局变量，函数外部无法读取函数内部的局部变量 但实际上 JavaScript 语法并不支持块级作用域，函数中的参数和变量在外部不可见，在内部可见 12345678910var foo = function() &#123; var a = 3, b = 5; var bar = function() &#123; var a = 4, b = 6; console.log('a ' + a + ', b ' + b); // a = 4, b = 6 &#125;() console.log('a ' + a + ', b ' + b); // a = 3, b = 5&#125;() 闭包 Closure闭包就是能够读取其他函数内部变量的函数 由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用： 可以读取函数内部的变量 让这些变量的值始终保持在内存中 123456789101112131415161718192021function f1() &#123; var n = 999; nAdd = function () &#123; n += 1 &#125; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000 匿名函数本身就是闭包 回调 Callback回调函数原理：“我现在出发，到了通知你”。这是一个异步的流程，“我出发”这个过程中（函数执行），“你” 可以去做任何事，“到了”（函数执行完毕）“通知你”（回调）进行之后的流程。 123456789function doSomething(callback) &#123; callback(1,2);&#125;function numberAdd(a,b) &#123; document.write(a+b);&#125;doSomething(numberAdd);//3 模块 Module 模块是一个提供接口却隐藏状态与实现的函数或对象。]]></content>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
